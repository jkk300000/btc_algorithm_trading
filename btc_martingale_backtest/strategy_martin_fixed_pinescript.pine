// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© s4wlsrud

// ë¹„íŠ¸ê²Ÿ ê¸°ì¤€ 25000% ìˆ˜ìµ, mmd 84

// ë¬¼ë¦´ê±° ëŒ€ë¹„í•´ì„œ 10ê°œ ë‹¤ ë¬¼íƒ€ê¸° í•œ í›„ì— ì´ íˆ¬ì… ê¸ˆì•¡ 100% íˆ¬ì…. ê¸°ì¤€ì€ 20%í•˜ë½


//@version=6
strategy("btc atr ë¬¼íƒ€ê¸° ë°”ì´ë‚¸ìŠ¤, ì •í™•í•œ í‰ë‹¨ê°€ ê³„ì‚° ì ìš© 1ì´ˆ", overlay=true, fill_orders_on_standard_ohlc=true, initial_capital=550, default_qty_type=strategy.percent_of_equity, default_qty_value=100, process_orders_on_close=false, commission_value=0.05, margin_long=1, slippage = 15)
import PineCoders/Time/5

// Convert dates to timestamps (defined only once)
start_time = input.time(timestamp("2025-07-09T09:36:00+09:00"), title="ìë™ë§¤ë§¤ ì‹œì‘")
end_time = input.time(timestamp("2026-12-30T11:09:00+09:00"), title="ìë™ë§¤ë§¤ ì¢…ë£Œ")

in_backtest_period = (time >= start_time) and (time <= end_time)

// ğŸ†• 1ì´ˆë´‰ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (naì¼ ë•Œ 1ë¶„ë´‰ ë°ì´í„° ì‚¬ìš©)
close_1s = request.security('BINANCE:BTCUSDT.P', '1S', close)
high_1s = request.security('BINANCE:BTCUSDT.P', '1S', high)
low_1s = request.security('BINANCE:BTCUSDT.P', '1S', low)

// ğŸ†• 1ì´ˆë´‰ ë°ì´í„° ì‚¬ìš© ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
var bool use_1s_data = false
if not na(close_1s)
    use_1s_data := true

// ğŸ†• 1ì´ˆë´‰ ë°ì´í„°ê°€ naì¼ ë•Œ 1ë¶„ë´‰ ë°ì´í„°ë¡œ ëŒ€ì²´
close_price = na(close_1s) ? close : close_1s
high_price = na(high_1s) ? high : high_1s
low_price = na(low_1s) ? low : low_1s

// --- ìŠ¤í€´ì¦ˆ ëª¨ë©˜í…€ ì§€í‘œ ---
length = input(20, title="BB Length")
mult = input(2.0, title="BB MultFactor")
lengthKC = input(20, title="KC Length")
multKC = input(1, title="KC MultFactor")
useTrueRange = input.bool(true, title="Use TrueRange (KC)")

// Calculate BB
source = close
basis = ta.sma(source, length)
dev = multKC * ta.stdev(source, length)
upperBB = basis + dev
lowerBB = basis - dev

// Calculate KC
ma = ta.sma(source, lengthKC)
range1 = useTrueRange ? ta.tr : (high - low)
rangema = ta.sma(range1, lengthKC)
upperKC = ma + rangema * multKC
lowerKC = ma - rangema * multKC

sqzOn = (lowerBB > lowerKC) and (upperBB < upperKC)
sqzOff = (lowerBB < lowerKC) and (upperBB > upperKC)
noSqz = (sqzOn == false) and (sqzOff == false)

val = ta.linreg(source - math.avg(math.avg(ta.highest(high, lengthKC), ta.lowest(low, lengthKC)), ta.sma(close, lengthKC)), lengthKC, 0)

// bcolor ê³„ì‚°
bcolor = val > 0 ? (val > nz(val[1]) ? color.lime : color.green) : (val < nz(val[1]) ? color.red : color.maroon)

// scolor ê³„ì‚°
scolor = noSqz ? color.blue : sqzOn ? color.black : color.gray

highest_price = ta.highest(high, 1)
lowest_price = ta.lowest(low, 1)

//atr
atr = ta.atr(14)

//vwap
vwap = ta.vwap(hlc3)
vwap4 = request.security('BINANCE:BTCUSDT.P', '240', vwap)

// ema
ema350 = ta.ema(close, 350)

// --- ë°”ì´ë‚¸ìŠ¤ í‰ê· ê°€ ê³„ì‚° ë³€ìˆ˜ë“¤ ---
var float total_cost = 0.0  // ì´ ë§¤ìˆ˜ ê¸ˆì•¡
var float total_quantity = 0.0  // ì´ ë§¤ìˆ˜ ìˆ˜ëŸ‰
var float avgPrice = 0.0  // ë°”ì´ë‚¸ìŠ¤ í‰ê· ê°€

// ğŸ†• ìë³¸ ë¶„í•  ê´€ë¦¬
var float first_half_capital = na  // ì²« ë²ˆì§¸ ì ˆë°˜ ìë³¸ (1-10ë²ˆ ì§„ì…ìš©)
var float second_half_capital = na  // ë‘ ë²ˆì§¸ ì ˆë°˜ ìë³¸ (ê¸´ê¸‰ ì§„ì…ìš©)

float capitalPerOnce = na
var float positionSize = na
var float initialEntryPrice = na
var float secondEntryPrice = na

var int entryCount = 0

int inputTrade = input.int(defval = 10, title= "ê±°ë˜ íˆ¬ì… íšŸìˆ˜/ìµœëŒ€ ê°’ì€ ì‹œë“œ ë¶„í•  ê°’ê³¼ ê°™ìŒ", minval = 1)
float profit = input.float(defval = 1.0098, title = "ìµì ˆ%")
int leverage = input.int(defval=10, title="ë ˆë²„ë¦¬ì§€", minval=1, maxval=100)
int dividedLongCount = input.int(defval=20, title="ì‹œë“œ ë¶„í• ")
int additionalEntryPrice = input.int(defval = 100, title = "ë¬¼íƒ€ê¸° í•œë„", minval=1)

float initial_capital = strategy.equity * leverage

// ğŸ†• ê¸´ê¸‰ ì§„ì… í”Œë˜ê·¸
var bool emergency_entry_executed = false  // ê¸´ê¸‰ ì§„ì… ì‹¤í–‰ ì—¬ë¶€

// ğŸ†• ë™ì  ìë³¸ ë¶„í•  ê³„ì‚° (ìë³¸ ì¦ê°€ ì‹œ ì¬ê³„ì‚°)
if na(first_half_capital) or math.abs(initial_capital - (first_half_capital + second_half_capital)) > 1
    first_half_capital := initial_capital / 2  // ì²« ë²ˆì§¸ ì ˆë°˜
    second_half_capital := initial_capital / 2  // ë‘ ë²ˆì§¸ ì ˆë°˜ (ê¸´ê¸‰ ì§„ì…ìš©)

// ì¼ë°˜ ì§„ì…ìš© í¬ì§€ì…˜ í¬ê¸° (ì²« ë²ˆì§¸ ì ˆë°˜ ìë³¸ ì‚¬ìš©)
capitalPerOnce := first_half_capital / dividedLongCount

bool exitCondition = false

var bool afterPartialExit = false
var float entryPrice = na

var bool time_frame_minute = false

var float initialPositionSize = na  // ì´ˆê¸° positionSize ì €ì¥
var float stoploss = na

// ë°”ì´ë‚¸ìŠ¤ í‰ê· ê°€ ê³„ì‚° í•¨ìˆ˜
calculate_binance_avg_price(current_total_cost, current_total_quantity, new_price, new_quantity) =>
    if current_total_quantity <= 0
        new_price
    else
        new_total_cost = current_total_cost + (new_price * new_quantity)
        new_total_quantity = current_total_quantity + new_quantity
        new_total_cost / new_total_quantity

// Entry Logic
positionSize := math.round(capitalPerOnce / close * 1000)/ 1000
stoploss := additionalEntryPrice - (2 * atr)   

// ì¼ë°˜ ì§„ì… ì¡°ê±´ (1-10ë²ˆì§¸ ì§„ì…)
if strategy.opentrades < inputTrade and positionSize > 0 
    // First Entry - ğŸ†• 1ì´ˆë´‰ ê°€ê²© ì‚¬ìš©
    if (val > 0 and entryCount == 0 and close > open) 
        initialEntryPrice := close_1s  // ğŸ†• 1ì´ˆë´‰ close ì‚¬ìš©
        initialPositionSize := positionSize  // ì´ˆê¸° ì§„ì… ì‹œ positionSize ì €ì¥
        
        // ë°”ì´ë‚¸ìŠ¤ í‰ê· ê°€ ê³„ì‚° - ğŸ†• 1ì´ˆë´‰ ê°€ê²© ì‚¬ìš©
        total_cost := close_1s * positionSize
        total_quantity := positionSize
        avgPrice := total_cost / total_quantity
        
        strategy.order("longPosition", strategy.long, qty=positionSize, limit=close_1s)  // ğŸ†• 1ì´ˆë´‰ ê°€ê²©ìœ¼ë¡œ ì§€ì •ê°€ ì£¼ë¬¸
        
        entryCount := 1
       
        log.info("Entry 1 at {0} (1ì´ˆë´‰), avgPrice: {1}, initialPositionSize : {2}", close_1s, avgPrice, initialPositionSize)
        
    // ì¼ë°˜ ë¬¼íƒ€ê¸° ì¡°ê±´ (1-9ë²ˆì§¸ ì§„ì…) - ê¸´ê¸‰ ì§„ì… ì´í›„ì—ëŠ” ì‹¤í–‰í•˜ì§€ ì•ŠìŒ
    if (entryCount >= 1 and entryCount < inputTrade and not emergency_entry_executed)
        stoploss := additionalEntryPrice - (2 * atr)
        price_gap = avgPrice - close_1s  // ğŸ†• 1ì´ˆë´‰ ê°€ê²© ì‚¬ìš©
        
        if price_gap > stoploss * entryCount and close > ema350
            secondEntryPrice := close_1s  // ğŸ†• 1ì´ˆë´‰ close ì‚¬ìš©
            
            // ë°”ì´ë‚¸ìŠ¤ í‰ê· ê°€ ê³„ì‚° (ì¦ë¶„ ë°©ì‹) - ğŸ†• 1ì´ˆë´‰ ê°€ê²© ì‚¬ìš©
            new_cost = close_1s * positionSize
            total_cost := total_cost + new_cost
            total_quantity := total_quantity + positionSize
            avgPrice := total_cost / total_quantity
            
            strategy.order("longPosition", strategy.long, qty=positionSize, limit=close_1s)  // ğŸ†• 1ì´ˆë´‰ ê°€ê²©ìœ¼ë¡œ ì§€ì •ê°€ ì£¼ë¬¸
            
            entryCount += 1
            
            log.info("Entry {0} at {1} (1ì´ˆë´‰), avgPrice: {2}", entryCount, close_1s, avgPrice)

// ğŸ†• ê¸´ê¸‰ ì§„ì… ì¡°ê±´ (ë³„ë„ ë¸”ë¡ìœ¼ë¡œ ë¶„ë¦¬)
if (entryCount == inputTrade and not emergency_entry_executed)  // 10ê°œ í¬ì§€ì…˜ì´ ëª¨ë‘ ì§„ì…ëœ ìƒíƒœì´ê³  ê¸´ê¸‰ ì§„ì…ì´ ì•„ì§ ì‹¤í–‰ë˜ì§€ ì•Šì•˜ì„ ë•Œ
    // í‰ê· ê°€ì—ì„œ 20% ì´ìƒ í•˜ë½ ì‹œ í˜„ì¬ê¹Œì§€ íˆ¬ì…í•œ ì „ì²´ í¬ì§€ì…˜ê³¼ ê°™ì€ ìˆ˜ëŸ‰ì„ ì¶”ê°€ ì§„ì…
    drop_percentage = ((avgPrice - close_1s) / avgPrice) * 100  // ğŸ†• 1ì´ˆë´‰ ê°€ê²© ì‚¬ìš©
    
    if drop_percentage >= 20
        // ğŸ†• í˜„ì¬ê¹Œì§€ íˆ¬ì…í•œ ì „ì²´ í¬ì§€ì…˜ê³¼ ê°™ì€ ìˆ˜ëŸ‰ì„ ê¸´ê¸‰ ì§„ì…
        total_position_size = total_quantity  // í˜„ì¬ê¹Œì§€ íˆ¬ì…í•œ ì „ì²´ í¬ì§€ì…˜ í¬ê¸°
        emergency_position_size = total_position_size  // ì „ì²´ í¬ì§€ì…˜ê³¼ ê°™ì€ ìˆ˜ëŸ‰
        
        // ë°”ì´ë‚¸ìŠ¤ í‰ê· ê°€ ê³„ì‚° (ì¦ë¶„ ë°©ì‹) - ğŸ†• 1ì´ˆë´‰ ê°€ê²© ì‚¬ìš©
        new_cost = close_1s * emergency_position_size
        total_cost := total_cost + new_cost
        total_quantity := total_quantity + emergency_position_size
        avgPrice := total_cost / total_quantity
        
        strategy.order("longPosition", strategy.long, qty=emergency_position_size, limit=close_1s)  // ğŸ†• 1ì´ˆë´‰ ê°€ê²©ìœ¼ë¡œ ì§€ì •ê°€ ì£¼ë¬¸
        
        entryCount += 1
        
        // ğŸ†• ê¸´ê¸‰ ì§„ì… í”Œë˜ê·¸ ì„¤ì •
        emergency_entry_executed := true
        
        log.info("ğŸš¨ ê¸´ê¸‰ë¬¼íƒ€ê¸° - Entry {0} at {1} (1ì´ˆë´‰), avgPrice: {2}, í•˜ë½ë¥ : {3}%, ì§„ì…ìˆ˜ëŸ‰: {4} (ì „ì²´ í¬ì§€ì…˜ê³¼ ê°™ì€ ìˆ˜ëŸ‰)", entryCount, close_1s, avgPrice, drop_percentage, emergency_position_size)
        log.info("ğŸš¨ ê¸´ê¸‰ë¬¼íƒ€ê¸° - í˜„ì¬ê¹Œì§€ íˆ¬ì…í•œ ì´ í¬ì§€ì…˜: {0}", total_position_size)

// Partial Exit Logic (ë°”ì´ë‚¸ìŠ¤ ë°©ì‹) - ğŸ†• 1ì´ˆë´‰ ê°€ê²© ì‚¬ìš©
if (entryCount >= 2 and (close > avgPrice * 1.0035) and not na(avgPrice)) 
    qty = strategy.position_size - initialPositionSize  // í˜„ì¬ í¬ì§€ì…˜ì—ì„œ ì´ˆê¸° positionSizeë¥¼ ì œì™¸í•œ ìˆ˜ëŸ‰ ì²­ì‚°
    
    // ë°”ì´ë‚¸ìŠ¤ ë°©ì‹: ë§¤ë„ ì‹œ í‰ê· ê°€ ìœ ì§€, ìˆ˜ëŸ‰ë§Œ ê°ì†Œ
    removed_cost = avgPrice * qty
    total_cost := total_cost - removed_cost
    total_quantity := total_quantity - qty
    
    strategy.order("partialExit", strategy.short, qty=qty, limit=close_1s, comment="ì´ˆê¸° íˆ¬ì… ë¬¼ëŸ‰ ë¹¼ê³  ì²­ì‚°")  // ğŸ†• 1ì´ˆë´‰ ê°€ê²©ìœ¼ë¡œ ì§€ì •ê°€ ì²­ì‚°
    log.info("ì´ˆê¸° íˆ¬ì… ë¬¼ëŸ‰ ë¹¼ê³  ì²­ì‚° at {0} (1ì´ˆë´‰), avgPrice: {1}, qty : {2}, strategy.position_size : {3}   ", close_1s, avgPrice, qty, strategy.position_size)
    entryCount := 1

// ì „ì²´ ì²­ì‚° - ğŸ†• 1ì´ˆë´‰ ê°€ê²© ì‚¬ìš©
if (entryCount == 1 and (close >= (avgPrice * profit))) 
    qty=positionSize
    strategy.order("fullExit", strategy.short, qty=qty, limit=close_1s, comment="ì „ì²´ ì²­ì‚°")  // ğŸ†• 1ì´ˆë´‰ ê°€ê²©ìœ¼ë¡œ ì§€ì •ê°€ ì²­ì‚°
    log.info("exit all at {0} (1ì´ˆë´‰), avgPrice: {1}", close_1s, avgPrice)
    
    // ë°”ì´ë‚¸ìŠ¤ ë°©ì‹: ëª¨ë“  í¬ì§€ì…˜ ì²­ì‚° ì‹œ ë³€ìˆ˜ ì´ˆê¸°í™”
    avgPrice := 0
    total_cost := 0
    total_quantity := 0
    initialEntryPrice := 0
    secondEntryPrice := 0
    
    entryCount := 0
    
    // ğŸ†• ìë³¸ ë¶„í•  ì´ˆê¸°í™” (ë‹¤ìŒ ê±°ë˜ë¥¼ ìœ„í•´)
    first_half_capital := na
    second_half_capital := na
    
    // ğŸ†• ê¸´ê¸‰ ì§„ì… í”Œë˜ê·¸ ì´ˆê¸°í™”
    emergency_entry_executed := false

// plot(avgPrice, color = color.black, style = plot.style_line) 