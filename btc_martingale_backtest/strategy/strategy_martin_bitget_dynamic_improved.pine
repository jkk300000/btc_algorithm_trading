// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© s4wlsrud

// ë°”ì´ë‚¸ìŠ¤ ë°±í…ŒìŠ¤íŒ… ê²°ê³¼ê°€ ë¹„íŠ¸ê²Ÿ ë³´ë‹¤ ë” ì•ˆì „í•¨ (2019 ~ 2021 ë°±í…ŒìŠ¤íŠ¸ ì‹œ ë°”ì´ë‚¸ìŠ¤ëŠ” ìˆ˜ìµì´ì§€ë§Œ ë¹„íŠ¸ê²Ÿì€ ì²­ì‚°/ 2022.09 ~ í˜„ì¬ ë°±í…ŒìŠ¤íŠ¸ ì‹œì—ë„ 10% ì •ë„ ë” ë†’ìŒ / ê°™ì€ ê¸°ê°„ ë™ì•ˆ ì´ë”ë¦¬ì›€ì„ ë³´ìœ í–ˆì„ ë•Œ ë³´ë‹¤ 80% ì •ë„ ë” ì„±ê³¼ê°€ ì¢‹ìŒ)

//@version=6
strategy("btc atr ë¬¼íƒ€ê¸° ë°”ì´ë‚¸ìŠ¤ 1ë¶„ë´‰ ETHUSDT.P - ê°œì„ ëœ ì²­ì‚°ê°€", overlay=true, fill_orders_on_standard_ohlc=true, initial_capital=5000, default_qty_type=strategy.percent_of_equity, default_qty_value=100, process_orders_on_close=false, commission_value=0.05, margin_long=1, slippage = 15)
import PineCoders/Time/5

// Convert dates to timestamps (defined only once)
start_time = input.time(timestamp("2025-07-09T09:36:00+09:00"), title="ìë™ë§¤ë§¤ ì‹œì‘")
end_time = input.time(timestamp("2026-12-30T11:09:00+09:00"), title="ìë™ë§¤ë§¤ ì¢…ë£Œ")

in_backtest_period = (time >= start_time) and (time <= end_time)

// --- ìŠ¤í€´ì¦ˆ ëª¨ë©˜í…€ ì§€í‘œ ---
length = input(20, title="BB Length")
mult = input(2.0, title="BB MultFactor")
lengthKC = input(20, title="KC Length")
multKC = input(1, title="KC MultFactor")
useTrueRange = input.bool(true, title="Use TrueRange (KC)")

// Calculate BB
source = close
basis = ta.sma(source, length)
dev = multKC * ta.stdev(source, length)
upperBB = basis + dev
lowerBB = basis - dev

// Calculate KC
ma = ta.sma(source, lengthKC)
range1 = useTrueRange ? ta.tr : (high - low)
rangema = ta.sma(range1, lengthKC)
upperKC = ma + rangema * multKC
lowerKC = ma - rangema * multKC

sqzOn = (lowerBB > lowerKC) and (upperBB < upperKC)
sqzOff = (lowerBB < lowerKC) and (upperBB > upperKC)
noSqz = (sqzOn == false) and (sqzOff == false)

val = ta.linreg(source - math.avg(math.avg(ta.highest(high, lengthKC), ta.lowest(low, lengthKC)), ta.sma(close, lengthKC)), lengthKC, 0)

// bcolor ê³„ì‚°
bcolor = val > 0 ? (val > nz(val[1]) ? color.lime : color.green) : (val < nz(val[1]) ? color.red : color.maroon)

// scolor ê³„ì‚°
scolor = noSqz ? color.blue : sqzOn ? color.black : color.gray

highest_price = ta.highest(high, 1)
lowest_price = ta.lowest(low, 1)

//atr
atr = ta.atr(14)

//vwap
vwap = ta.vwap(hlc3)
vwap4 = request.security('BINANCE:BTCUSDT.P', '240', vwap)

// ema
ema350 = ta.ema(close, 350)

// --- ë°”ì´ë‚¸ìŠ¤ í‰ê· ê°€ ê³„ì‚° ë³€ìˆ˜ë“¤ ---
var float total_cost = 0.0  // ì´ ë§¤ìˆ˜ ê¸ˆì•¡
var float total_quantity = 0.0  // ì´ ë§¤ìˆ˜ ìˆ˜ëŸ‰
var float avgPrice = 0.0  // ë°”ì´ë‚¸ìŠ¤ í‰ê· ê°€

// ğŸ†• ìë³¸ ë¶„í•  ê´€ë¦¬
var float first_half_capital = na  // ì²« ë²ˆì§¸ ì ˆë°˜ ìë³¸ (1-10ë²ˆ ì§„ì…ìš©)
var float second_half_capital = na  // ë‘ ë²ˆì§¸ ì ˆë°˜ ìë³¸ (ê¸´ê¸‰ ì§„ì…ìš©)

float capitalPerOnce = na
var float positionSize = na
var float initialEntryPrice = na
var float secondEntryPrice = na

var int entryCount = 0

int inputTrade = input.int(defval = 10, title= "ê±°ë˜ íˆ¬ì… íšŸìˆ˜/ìµœëŒ€ ê°’ì€ ì‹œë“œ ë¶„í•  ê°’ê³¼ ê°™ìŒ", minval = 1)
float profit = input.float(defval = 1.01, title = "ìµì ˆ%")
float partial_profit = input.float(defval = 1.01, title = "ë¶€ë¶„ ì²­ì‚° ìµì ˆ %")
int leverage = input.int(defval=5, title="ë ˆë²„ë¦¬ì§€", minval=1, maxval=100)
int dividedLongCount = input.int(defval=20, title="ì‹œë“œ ë¶„í• ")
int additionalEntryPrice = input.int(defval = 70, title = "ë¬¼íƒ€ê¸° í•œë„", minval=1)
float atr_multiplier = input.float(defval = 2.5, title = "atr ë²”ìœ„")

float initial_capital = strategy.equity * leverage
var float cycle_start_capital = na  // ğŸ†• ì‚¬ì´í´ ì‹œì‘ ì‹œ ìë³¸ (ë ˆë²„ë¦¬ì§€ ê³„ì‚°ìš©)
// ğŸ†• ê¸´ê¸‰ ì§„ì… í”Œë˜ê·¸
var bool emergency_entry_executed = false  // ê¸´ê¸‰ ì§„ì… ì‹¤í–‰ ì—¬ë¶€

// ğŸ†• ë™ì  ìë³¸ ë¶„í•  ê³„ì‚° (ìë³¸ ì¦ê°€ ì‹œ ì¬ê³„ì‚°)
if na(first_half_capital) or math.abs(initial_capital - (first_half_capital + second_half_capital)) > 1
    first_half_capital := initial_capital / 2  // ì²« ë²ˆì§¸ ì ˆë°˜
    second_half_capital := initial_capital / 2  // ë‘ ë²ˆì§¸ ì ˆë°˜ (ê¸´ê¸‰ ì§„ì…ìš©)

// ì¼ë°˜ ì§„ì…ìš© í¬ì§€ì…˜ í¬ê¸° (ì²« ë²ˆì§¸ ì ˆë°˜ ìë³¸ ì‚¬ìš©)
capitalPerOnce := first_half_capital / dividedLongCount

bool exitCondition = false

var bool afterPartialExit = false
var float entryPrice = na

var bool time_frame_minute = false

var float initialPositionSize = na  // ì´ˆê¸° positionSize ì €ì¥
var float stoploss = na

// ğŸ†• ê°œì„ ëœ ë°”ì´ë‚¸ìŠ¤ ì²­ì‚°ê°€ ê³„ì‚° ë³€ìˆ˜ë“¤
var float liquidation_price = na
var float total_position_value = 0.0

// ğŸ†• ê°œì„ ëœ ë™ì  ë ˆë²„ë¦¬ì§€ ê³„ì‚° í•¨ìˆ˜ (ë°”ì´ë‚¸ìŠ¤ ê³µì‹ ê¸°ë°˜)
calculate_actual_leverage(entry_count, leverage, divided_count, total_position_value, current_equity) =>
    if entry_count <= 0 or leverage <= 0 or divided_count <= 0
        0.0
    else
        // ğŸ†• ë°”ì´ë‚¸ìŠ¤ ê³µì‹: ì‹¤ì œë ˆë²„ë¦¬ì§€ = ì´í¬ì§€ì…˜ê°€ì¹˜ Ã· ì´ìì‚°
        // ì´í¬ì§€ì…˜ê°€ì¹˜ = total_position_value (ì‹¤ì œ ê³„ì‚°ëœ ê°’)
        // ì´ìì‚° = current_equity (initial_capital - ê³ ì •ëœ ì´ˆê¸° ìë³¸)
        // ì‹¤ì œë ˆë²„ë¦¬ì§€ = total_position_value Ã· current_equity
        total_position_value / current_equity

// ğŸ†• ê°œì„ ëœ ë°”ì´ë‚¸ìŠ¤ ì²­ì‚°ê°€ ê³„ì‚° í•¨ìˆ˜ (entryCountì— ë”°ë¥¸ ë™ì  ë ˆë²„ë¦¬ì§€ ì ìš©)
calculate_martingale_liquidation_price(avg_price, entry_count, leverage, divided_count, total_position_value, current_equity) =>
    if entry_count <= 2
        na  // 1-2íšŒ ì§„ì… ì‹œì—ëŠ” ì²­ì‚°ê°€ ì—†ìŒ
    else
        // ğŸ†• ìƒˆë¡œìš´ ë ˆë²„ë¦¬ì§€ ê³„ì‚° í•¨ìˆ˜ ì‚¬ìš© (ì´í¬ì§€ì…˜ê°€ì¹˜/ì´ìì‚° ë°©ì‹)
        actual_leverage = calculate_actual_leverage(entry_count, leverage, divided_count, total_position_value, current_equity)
        
        // ğŸ†• ë ˆë²„ë¦¬ì§€ê°€ 1.0 ë¯¸ë§Œì´ì–´ë„ ì´ë¡ ìƒ ì²­ì‚°ê°€ ê³„ì‚° (ì•ˆì „ì¥ì¹˜)
        if actual_leverage < 1.0
            // ğŸ†• ì´ë¡ ìƒ ì²­ì‚°ê°€: í‰ê· ê°€ Ã— (1 - 1/ë ˆë²„ë¦¬ì§€) - ì´ëŠ” ì‹¤ì œ ì²­ì‚°ê°€ê°€ ì•„ë‹Œ ì´ë¡ ê°’
            // ì‹¤ì œë¡œëŠ” ë ˆë²„ë¦¬ì§€ê°€ ë‚®ì•„ì„œ ì²­ì‚° ìœ„í—˜ì´ ë‚®ìŒ
            avg_price * (1 - 1/actual_leverage)
        else
            // ğŸ†• ì˜¬ë°”ë¥¸ ë°”ì´ë‚¸ìŠ¤ ì²­ì‚°ê°€ ê³µì‹: Entry Price - ((Entry Price / Leverage) * (1 + Maintenance Margin))
            // Maintenance Margin = 0.5% (0.005)
            // ì´ ê³µì‹ì´ ë°”ì´ë‚¸ìŠ¤ì˜ í‘œì¤€ ì²­ì‚°ê°€ ê³„ì‚° ê³µì‹
            maintenance_margin = 0.005
            avg_price - ((avg_price / actual_leverage) * (1 + maintenance_margin))

// ğŸ†• ì²­ì‚°ê°€ê¹Œì§€ ë‚¨ì€ ê±°ë¦¬ ê³„ì‚° (ë°±ë¶„ìœ¨)
calculate_distance_to_liquidation() =>
    if strategy.position_size > 0 and not na(avgPrice) and not na(liquidation_price)
        distance_pct = ((close - liquidation_price) / close) * 100
        distance_pct
    else
        na

// ğŸ†• ì²­ì‚° ìœ„í—˜ë„ ê²½ê³  ì—¬ë¶€ í™•ì¸
is_liquidation_warning(distance_percentage) =>
    distance_percentage <= 20  // 20% ì´í•˜ì¼ ë•Œ ê²½ê³ 

// ë°”ì´ë‚¸ìŠ¤ í‰ê· ê°€ ê³„ì‚° í•¨ìˆ˜
calculate_binance_avg_price(current_total_cost, current_total_quantity, new_price, new_quantity) =>
    if current_total_quantity <= 0
        new_price
    else
        new_total_cost = current_total_cost + (new_price * new_quantity)
        new_total_quantity = current_total_quantity + new_quantity
        new_total_cost / new_total_quantity

// Entry Logic
positionSize := math.round(capitalPerOnce / close * 1000)/ 1000
stoploss := additionalEntryPrice - (atr_multiplier * atr)   

// ì¼ë°˜ ì§„ì… ì¡°ê±´ (1-10ë²ˆì§¸ ì§„ì…)
if strategy.opentrades < inputTrade and positionSize > 0 
    // First Entry
    if (val > 0 and entryCount == 0  and  close > open) 
        initialEntryPrice := close
        initialPositionSize := positionSize  // ì´ˆê¸° ì§„ì… ì‹œ positionSize ì €ì¥
        
        // ğŸ†• ì‚¬ì´í´ ì‹œì‘ ì‹œ ìë³¸ ê³ ì •
        cycle_start_capital := strategy.equity
        
        // ë°”ì´ë‚¸ìŠ¤ í‰ê· ê°€ ê³„ì‚°
        total_cost := close * positionSize
        total_quantity := positionSize
        avgPrice := total_cost / total_quantity
        
        // ğŸ†• ë°”ì´ë‚¸ìŠ¤ ì²­ì‚°ê°€ ê³„ì‚° (ì²« ì§„ì… ì‹œ) - ì²­ì‚°ê°€ ì—†ìŒ
        total_position_value := total_quantity * avgPrice
        liquidation_price := na
        
        strategy.order("longPosition", strategy.long, qty=positionSize)
        
        entryCount := 1
       
        log.info("Entry 1 at {0}, avgPrice: {1}, initialPositionSize : {2}, ì²­ì‚°ê°€: ì—†ìŒ (ì²« ì§„ì…)", close, avgPrice, initialPositionSize)
        
    // ì¼ë°˜ ë¬¼íƒ€ê¸° ì¡°ê±´ (1-9ë²ˆì§¸ ì§„ì…) - ê¸´ê¸‰ ì§„ì… ì´í›„ì—ëŠ” ì‹¤í–‰í•˜ì§€ ì•ŠìŒ
    if (entryCount >= 1 and entryCount < inputTrade and not emergency_entry_executed)
        stoploss := additionalEntryPrice - (atr_multiplier * atr)
        price_gap = avgPrice - close  // ë°”ì´ë‚¸ìŠ¤ í‰ê· ê°€ê²© ì‚¬ìš©
        
        if price_gap > stoploss * entryCount and close > ema350
            secondEntryPrice := close 
            
            // ë°”ì´ë‚¸ìŠ¤ í‰ê· ê°€ ê³„ì‚° (ì¦ë¶„ ë°©ì‹)
            new_cost = close * positionSize
            total_cost := total_cost + new_cost
            total_quantity := total_quantity + positionSize
            avgPrice := total_cost / total_quantity
            
            // ğŸ†• ë°”ì´ë‚¸ìŠ¤ ì²­ì‚°ê°€ ì¬ê³„ì‚°
            total_position_value := total_quantity * avgPrice
            
            strategy.order("longPosition", strategy.long, qty=positionSize)
            
            entryCount += 1
            
            // ğŸ†• entryCount ì—…ë°ì´íŠ¸ í›„ ì²­ì‚°ê°€ ì¬ê³„ì‚°
            liquidation_price := calculate_martingale_liquidation_price(avgPrice, entryCount, leverage, dividedLongCount, total_position_value, cycle_start_capital)
            
            log.info("Entry {0} at {1}, avgPrice: {2}, ì²­ì‚°ê°€: {3}", entryCount, close, avgPrice, liquidation_price)

// ğŸ†• ê¸´ê¸‰ ì§„ì… ì¡°ê±´ (ë³„ë„ ë¸”ë¡ìœ¼ë¡œ ë¶„ë¦¬)
if (entryCount == inputTrade and not emergency_entry_executed)  // 10ê°œ í¬ì§€ì…˜ì´ ëª¨ë‘ ì§„ì…ëœ ìƒíƒœì´ê³  ê¸´ê¸‰ ì§„ì…ì´ ì•„ì§ ì‹¤í–‰ë˜ì§€ ì•Šì•˜ì„ ë•Œ
    // í‰ê· ê°€ì—ì„œ 2% ì´ìƒ í•˜ë½ ì‹œ í˜„ì¬ê¹Œì§€ íˆ¬ì…í•œ ì „ì²´ í¬ì§€ì…˜ê³¼ ê°™ì€ ìˆ˜ëŸ‰ì„ ì¶”ê°€ ì§„ì…
    drop_percentage = ((avgPrice - close) / avgPrice) * 100
    
    if drop_percentage >= 2
        // ğŸ†• í˜„ì¬ê¹Œì§€ íˆ¬ì…í•œ ì „ì²´ í¬ì§€ì…˜ê³¼ ê°™ì€ ìˆ˜ëŸ‰ì„ ê¸´ê¸‰ ì§„ì…
        total_position_size = total_quantity  // í˜„ì¬ê¹Œì§€ íˆ¬ì…í•œ ì „ì²´ í¬ì§€ì…˜ í¬ê¸°
        emergency_position_size = total_position_size  // ì „ì²´ í¬ì§€ì…˜ê³¼ ê°™ì€ ìˆ˜ëŸ‰
        
        // ë°”ì´ë‚¸ìŠ¤ í‰ê· ê°€ ê³„ì‚° (ì¦ë¶„ ë°©ì‹)
        new_cost = close * emergency_position_size
        total_cost := total_cost + new_cost
        total_quantity := total_quantity + emergency_position_size
        avgPrice := total_cost / total_quantity
        
        // ğŸ†• ë°”ì´ë‚¸ìŠ¤ ì²­ì‚°ê°€ ì¬ê³„ì‚° (ê¸´ê¸‰ ì§„ì… í›„)
        total_position_value := total_quantity * avgPrice
        liquidation_price := calculate_martingale_liquidation_price(avgPrice, entryCount, leverage, dividedLongCount, total_position_value, cycle_start_capital)
        
        strategy.order("longPosition", strategy.long, qty=emergency_position_size)
        
        entryCount += 1
        
        // ğŸ†• ê¸´ê¸‰ ì§„ì… í”Œë˜ê·¸ ì„¤ì •
        emergency_entry_executed := true
        
        log.info("ğŸš¨ ê¸´ê¸‰ë¬¼íƒ€ê¸° - Entry {0} at {1}, avgPrice: {2}, í•˜ë½ë¥ : {3}%, ì§„ì…ìˆ˜ëŸ‰: {4} (ì „ì²´ í¬ì§€ì…˜ê³¼ ê°™ì€ ìˆ˜ëŸ‰), ì²­ì‚°ê°€: {5}", entryCount, close, avgPrice, drop_percentage, emergency_position_size, liquidation_price)
        log.info("ğŸš¨ ê¸´ê¸‰ë¬¼íƒ€ê¸° - í˜„ì¬ê¹Œì§€ íˆ¬ì…í•œ ì´ í¬ì§€ì…˜: {0}", total_position_size)

// ğŸ†• ê°œì„ ëœ ë°”ì´ë‚¸ìŠ¤ ì²­ì‚°ê°€ ëª¨ë‹ˆí„°ë§
if strategy.position_size > 0 and entryCount >= 3 and not na(liquidation_price) 
    // ë™ì  ë ˆë²„ë¦¬ì§€ ê³„ì‚°
    float actual_leverage = calculate_actual_leverage(entryCount, leverage, dividedLongCount, total_position_value, cycle_start_capital)
    
    // ì²­ì‚°ê°€ ìœ„í—˜ë„ ê³„ì‚°
    float distance_to_liquidation = close - liquidation_price
    float distance_percentage = (distance_to_liquidation / liquidation_price) * 100
    
    // ì´ë¡ ìƒ ì²­ì‚° í•˜ë½ë¥  ê³„ì‚°
    float theoretical_liquidation_drop = actual_leverage > 0 ? 100 / actual_leverage : 0
    
    // í˜„ì¬ í•˜ë½ë¥  ê³„ì‚°
    float current_drop_percentage = ((avgPrice - close) / avgPrice) * 100
    
    // ì²­ì‚° ìœ„í—˜ ê²½ê³  (ì²­ì‚°ê°€ ëŒ€ë¹„ 5% ì´ë‚´)
    if close <= liquidation_price * 1.05
        log.info("ğŸš¨ ì²­ì‚° ìœ„í—˜: í˜„ì¬ê°€={0}, ì²­ì‚°ê°€={1}, ê±°ë¦¬={2}%", close, liquidation_price, distance_percentage)
        log.info("ğŸš¨ ë ˆë²„ë¦¬ì§€ ì •ë³´: ì§„ì…íšŸìˆ˜={0}, ì‹¤ì œë ˆë²„ë¦¬ì§€={1}ë°°, ì´ë¡ ìƒì²­ì‚°í•˜ë½ë¥ ={2}%", entryCount, actual_leverage, str.tostring(theoretical_liquidation_drop))
        log.info("ğŸš¨ í˜„ì¬ í•˜ë½ë¥ : {0}% (ì²­ì‚°ê¹Œì§€ {1}% ì—¬ìœ )", current_drop_percentage, str.tostring(theoretical_liquidation_drop - current_drop_percentage))
    
    // ì‹¤ì œ ì²­ì‚° ì²´í¬ (ë” ì•ˆì „í•œ ì¡°ê±´ìœ¼ë¡œ ìˆ˜ì •)
    if close <= liquidation_price * 1.01  // 1% ì—¬ìœ ë¡œ ì²­ì‚°
        strategy.close_all("ë°”ì´ë‚¸ìŠ¤ ì²­ì‚°")
        log.info("ğŸš¨ ë°”ì´ë‚¸ìŠ¤ ì²­ì‚° ë°œìƒ: í˜„ì¬ê°€={0}, ì²­ì‚°ê°€={1}", close, liquidation_price)
        log.info("ğŸš¨ ë§ˆì§„ì½œ ìƒì„¸: í‰ë‹¨ê°€={0}, ì§„ì…íšŸìˆ˜={1}, ì‹¤ì œë ˆë²„ë¦¬ì§€={2}ë°°", avgPrice, entryCount, actual_leverage)
        log.info("ğŸš¨ ì†ì‹¤ë¥ : {0}% (ì´ë¡ ìƒ ì²­ì‚°ë¥ : {1}%)", current_drop_percentage, str.tostring(theoretical_liquidation_drop))

// Partial Exit Logic (ë°”ì´ë‚¸ìŠ¤ ë°©ì‹)
if (entryCount >= 2 and (close > avgPrice * partial_profit) and  not na(avgPrice)) 
    qty = strategy.position_size - initialPositionSize  // í˜„ì¬ í¬ì§€ì…˜ì—ì„œ ì´ˆê¸° positionSizeë¥¼ ì œì™¸í•œ ìˆ˜ëŸ‰ ì²­ì‚°
    
    // ë°”ì´ë‚¸ìŠ¤ ë°©ì‹: ë§¤ë„ ì‹œ í‰ê· ê°€ ìœ ì§€, ìˆ˜ëŸ‰ë§Œ ê°ì†Œ
    removed_cost = avgPrice * qty
    total_cost := total_cost - removed_cost
    total_quantity := total_quantity - qty
    
    strategy.close("longPosition", comment="ì´ˆê¸° íˆ¬ì… ë¬¼ëŸ‰ ë¹¼ê³  ì²­ì‚°", qty = qty)
    
    // ğŸ†• ìˆ˜ì •: Partial Exit í›„ì—ëŠ” entryCountë¥¼ 1ë¡œ ì„¤ì •í•˜ê³  ì²­ì‚°ê°€ë¥¼ naë¡œ ì„¤ì •
    entryCount := 1
    liquidation_price := na  // Partial Exit í›„ì—ëŠ” ì²­ì‚°ê°€ ì—†ìŒ
    cycle_start_capital := na  // ğŸ†• ì‚¬ì´í´ ì‹œì‘ ìë³¸ ì´ˆê¸°í™” (Partial Exit í›„)
    
    log.info("ì´ˆê¸° íˆ¬ì… ë¬¼ëŸ‰ ë¹¼ê³  ì²­ì‚° at {0}, avgPrice: {1}, qty : {2}, strategy.position_size : {3}, ì²­ì‚°ê°€: ì—†ìŒ (Partial Exit í›„), entryCount: {4}", close, avgPrice, qty, strategy.position_size, entryCount)

// ì „ì²´ ì²­ì‚°
if (entryCount == 1 and (close >= (avgPrice * profit))) 
    qty=positionSize
    strategy.close_all("ì¢…ë£Œ")
    log.info("exit all at {0}, avgPrice: {1}", close, avgPrice)
    
    // ë°”ì´ë‚¸ìŠ¤ ë°©ì‹: ëª¨ë“  í¬ì§€ì…˜ ì²­ì‚° ì‹œ ë³€ìˆ˜ ì´ˆê¸°í™”
    avgPrice := 0
    total_cost := 0
    total_quantity := 0
    initialEntryPrice := 0
    secondEntryPrice := 0
    liquidation_price := na
    total_position_value := 0.0
    cycle_start_capital := na  // ğŸ†• ì‚¬ì´í´ ì‹œì‘ ìë³¸ ì´ˆê¸°í™”
    
    entryCount := 0
    
    // ğŸ†• ìë³¸ ë¶„í•  ì´ˆê¸°í™” (ë‹¤ìŒ ê±°ë˜ë¥¼ ìœ„í•´)
    first_half_capital := na
    second_half_capital := na
    
    // ğŸ†• ê¸´ê¸‰ ì§„ì… í”Œë˜ê·¸ ì´ˆê¸°í™”
    emergency_entry_executed := false

// ğŸ†• ê°œì„ ëœ ì²­ì‚°ê°€ ì •ë³´ë¥¼ ì°¨íŠ¸ì— í‘œì‹œ
if barstate.islast and strategy.position_size > 0 and not na(avgPrice)
    var table liquidation_table = table.new(position.top_right, 2, 8, bgcolor=color.white, border_width=1)
    
    current_liquidation_price = liquidation_price
    distance_to_liquidation = calculate_distance_to_liquidation()
    actual_leverage = calculate_actual_leverage(entryCount, leverage, dividedLongCount, total_position_value, cycle_start_capital)
    
    if not na(current_liquidation_price) and not na(distance_to_liquidation) and not na(actual_leverage)
        table.cell(liquidation_table, 0, 0, "ì²­ì‚°ê°€ ì •ë³´", text_color=color.black, bgcolor=color.red)
        table.cell(liquidation_table, 1, 0, "ê°’", text_color=color.black, bgcolor=color.red)
        
        table.cell(liquidation_table, 0, 1, "í˜„ì¬ê°€", text_color=color.black)
        table.cell(liquidation_table, 1, 1, str.tostring(close, "#.##"), text_color=color.black)
        
        table.cell(liquidation_table, 0, 2, "í‰ê· ê°€", text_color=color.black)
        table.cell(liquidation_table, 1, 2, str.tostring(avgPrice, "#.##"), text_color=color.black)
        
        table.cell(liquidation_table, 0, 3, "ì²­ì‚°ê°€", text_color=color.black)
        table.cell(liquidation_table, 1, 3, str.tostring(current_liquidation_price, "#.##"), text_color=color.red)
        
        table.cell(liquidation_table, 0, 4, "ì²­ì‚°ê°€ê¹Œì§€ ê±°ë¦¬", text_color=color.black)
        // ê±°ë¦¬ì— ë”°ë¥¸ ìƒ‰ìƒ ì„¤ì •
        distance_color = distance_to_liquidation <= 10 ? color.red : distance_to_liquidation <= 20 ? color.orange : color.green
        
        table.cell(liquidation_table, 1, 4, str.tostring(distance_to_liquidation, "#.##") + "%", text_color=distance_color)
        
        table.cell(liquidation_table, 0, 5, "ì§„ì…íšŸìˆ˜", text_color=color.black)
        table.cell(liquidation_table, 1, 5, str.tostring(entryCount), text_color=color.black)
        
        table.cell(liquidation_table, 0, 6, "ì‹¤ì œ ë ˆë²„ë¦¬ì§€", text_color=color.black)
        table.cell(liquidation_table, 1, 6, str.tostring(actual_leverage, "#.##") + "x", text_color=color.blue)
        
        table.cell(liquidation_table, 0, 7, "ì´ë¡ ìƒ ì²­ì‚°ë¥ ", text_color=color.black)
        theoretical_drop = actual_leverage > 0 ? 100 / actual_leverage : 0
        table.cell(liquidation_table, 1, 7, str.tostring(theoretical_drop, "#.##") + "%", text_color=color.purple)

// ğŸ†• ì²­ì‚°ê°€ ë¼ì¸ í‘œì‹œ (ì‹¤ì‹œê°„)
if strategy.position_size > 0 and not na(liquidation_price)
    line.new(bar_index - 1, liquidation_price, bar_index, liquidation_price, color=color.red, width=3, style=line.style_dashed)

// ğŸ†• í‰ê· ê°€ ë¼ì¸ í‘œì‹œ
plot(avgPrice, color = color.blue, style = plot.style_line, linewidth=2, title="í‰ê· ê°€")

// ğŸ†• ì²­ì‚° ìœ„í—˜ êµ¬ê°„ í‘œì‹œ
bgcolor(close <= liquidation_price * 1.05 and strategy.position_size > 0 and not na(liquidation_price) ? color.new(color.red, 90) : na, title="ì²­ì‚° ìœ„í—˜ êµ¬ê°„")
