// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© s4wlsrud

// profit : 6800 , mdd : 81.22
// ë°”ì´ë‚¸ìŠ¤ ì²­ì‚°ê°€ ê³„ì‚° ê³µì‹: ì²­ì‚°ê°€ = EP1BOTH - (WB - TMM1 - UPNL1 - cumB) / (Position1BOTH * MMRB)
// ì¶œì²˜: https://www.binance.com/en/support/faq/detail/b3c689c1f50a44cabb3a84e663b81d93
//
//@version=6
strategy("btc atr ë¬¼íƒ€ê¸° ë°”ì´ë‚¸ìŠ¤, ì •í™•í•œ í‰ë‹¨ê°€ ê³„ì‚° ì ìš© ìë™ë§¤ë§¤ 1ë¶„ë´‰", overlay=true, fill_orders_on_standard_ohlc=true, initial_capital=570, default_qty_type=strategy.percent_of_equity, default_qty_value=100, process_orders_on_close=false, commission_value=0.05, margin_long=1, slippage = 15)
import PineCoders/Time/5

// Convert dates to timestamps (defined only once)
start_time = input.time(timestamp("2025-08-07T22:15:00+09:00"), title="ìë™ë§¤ë§¤ ì‹œì‘")
end_time = input.time(timestamp("2026-12-30T11:09:00+09:00"), title="ìë™ë§¤ë§¤ ì¢…ë£Œ")

in_backtest_period = (time >= start_time) and (time <= end_time)

// --- ìŠ¤í€´ì¦ˆ ëª¨ë©˜í…€ ì§€í‘œ ---
length = input(20, title="BB Length")
mult = input(2.0, title="BB MultFactor")
lengthKC = input(20, title="KC Length")
multKC = input(1, title="KC MultFactor")
useTrueRange = input.bool(true, title="Use TrueRange (KC)")

// Calculate BB
source = close
basis = ta.sma(source, length)
dev = multKC * ta.stdev(source, length)
upperBB = basis + dev
lowerBB = basis - dev

// Calculate KC
ma = ta.sma(source, lengthKC)
range1 = useTrueRange ? ta.tr : (high - low)
rangema = ta.sma(range1, lengthKC)
upperKC = ma + rangema * multKC
lowerKC = ma - rangema * multKC

sqzOn = (lowerBB > lowerKC) and (upperBB < upperKC)
sqzOff = (lowerBB < lowerKC) and (upperBB > upperKC)
noSqz = (sqzOn == false) and (sqzOff == false)

val = ta.linreg(source - math.avg(math.avg(ta.highest(high, lengthKC), ta.lowest(low, lengthKC)), ta.sma(close, lengthKC)), lengthKC, 0)

// bcolor ê³„ì‚°
bcolor = val > 0 ? (val > nz(val[1]) ? color.lime : color.green) : (val < nz(val[1]) ? color.red : color.maroon)

// scolor ê³„ì‚°
scolor = noSqz ? color.blue : sqzOn ? color.black : color.gray

highest_price = ta.highest(high, 1)
lowest_price = ta.lowest(low, 1)

//atr
atr = ta.atr(14)

//vwap
vwap =ta.vwap(hlc3)
vwap4 = request.security('BINANCE:BTCUSDT.P', '240', vwap)

// --- ë°”ì´ë‚¸ìŠ¤ í‰ê· ê°€ ê³„ì‚° ë³€ìˆ˜ë“¤ ---
var float total_cost = 0.0  // ì´ ë§¤ìˆ˜ ê¸ˆì•¡
var float total_quantity = 0.0  // ì´ ë§¤ìˆ˜ ìˆ˜ëŸ‰
var float avgPrice = 0.0  // ë°”ì´ë‚¸ìŠ¤ í‰ê· ê°€

// --- ë°”ì´ë‚¸ìŠ¤ ì²­ì‚°ê°€ ê³„ì‚° ë³€ìˆ˜ë“¤ ---
var float liquidation_price = na
var float total_position_value = 0.0

float capitalPerOnce = na
var float positionSize = na
var float initialEntryPrice = na
var float secondEntryPrice = na

var int entryCount = 0

int inputTrade = input.int(defval = 10, title= "ê±°ë˜ íˆ¬ì… íšŸìˆ˜/ìµœëŒ€ ê°’ì€ ì‹œë“œ ë¶„í•  ê°’ê³¼ ê°™ìŒ", minval = 1)
float profit = input.float(defval = 1.013, title = "ìµì ˆ%")
int leverage = input.int(defval=10, title="ë ˆë²„ë¦¬ì§€", minval=1, maxval=100)
int dividedLongCount = input.int(defval=20, title="ì‹œë“œ ë¶„í• ")
int additionalEntryPrice = input.int(defval = 1500, title="ë¬¼íƒ€ê¸° í•œë„", minval=1)

// ğŸ†• ê³ ì •ëœ ì´ˆê¸° ìë³¸ ì‚¬ìš© (ì •í™•í•œ ì²­ì‚°ê°€ ê³„ì‚°ì„ ìœ„í•´)
var float initial_capital = strategy.equity * leverage 
var float cycle_start_capital = na  // ğŸ†• ì‚¬ì´í´ ì‹œì‘ ì‹œ ìë³¸ (ë ˆë²„ë¦¬ì§€ ê³„ì‚°ìš©)
capitalPerOnce := initial_capital / dividedLongCount

bool exitCondition = false

var bool afterPartialExit = false
var float entryPrice = na

var bool time_frame_minute = false

var float initialPositionSize = na  // ì´ˆê¸° positionSize ì €ì¥
var float stoploss = na

// ë°”ì´ë‚¸ìŠ¤ í‰ê· ê°€ ê³„ì‚° í•¨ìˆ˜
calculate_binance_avg_price(current_total_cost, current_total_quantity, new_price, new_quantity) =>
    if current_total_quantity <= 0
        new_price
    else
        new_total_cost = current_total_cost + (new_price * new_quantity)
        new_total_quantity = current_total_quantity + new_quantity
        new_total_cost / new_total_quantity

// ğŸ†• ì˜¬ë°”ë¥¸ ë°”ì´ë‚¸ìŠ¤ ì²­ì‚°ê°€ ê³µì‹ ê¸°ë°˜ ì‹¤ì œë ˆë²„ë¦¬ì§€ ê³„ì‚° í•¨ìˆ˜
calculate_actual_leverage(entry_count, leverage, divided_count, total_position_value, current_equity) =>
    if entry_count <= 0 or leverage <= 0 or divided_count <= 0
        0.0
    else
        // ğŸ†• ë°”ì´ë‚¸ìŠ¤ ê³µì‹: ì‹¤ì œë ˆë²„ë¦¬ì§€ = ì´í¬ì§€ì…˜ê°€ì¹˜ Ã· ì´ìì‚°
        // ì´í¬ì§€ì…˜ê°€ì¹˜ = total_position_value (ì‹¤ì œ ê³„ì‚°ëœ ê°’)
        // ì´ìì‚° = current_equity (initial_capital - ê³ ì •ëœ ì´ˆê¸° ìë³¸)
        // ì‹¤ì œë ˆë²„ë¦¬ì§€ = total_position_value Ã· current_equity
        total_position_value / current_equity

// ğŸ†• ë°”ì´ë‚¸ìŠ¤ ê³µì‹ ê¸°ë°˜ ì²­ì‚°ê°€ ê³„ì‚° í•¨ìˆ˜
calculate_martingale_liquidation_price(avg_price, entry_count, leverage, divided_count, total_position_value, current_equity) =>
    if entry_count <= 2
        na
    else
        // ğŸ†• ë°”ì´ë‚¸ìŠ¤ ê³µì‹: ì²­ì‚°ê°€ = EP1BOTH - (WB - TMM1 - UPNL1 - cumB) / (Position1BOTH * MMRB)
        // ì—¬ê¸°ì„œëŠ” ë‹¨ì¼ í¬ì§€ì…˜ë§Œ ìˆìœ¼ë¯€ë¡œ TMM1=0, UPNL1=0
        
        // í¬ì§€ì…˜ í¬ê¸° (USDT ê¸°ì¤€)
        position_notional = total_position_value
        
        // ìœ ì§€ì¦ê±°ê¸ˆë¥  ê²°ì • (í¬ì§€ì…˜ í¬ê¸°ì— ë”°ë¥¸ ë™ì  ê³„ì‚°)
        maintenance_margin_rate = 0.0
        maintenance_amount = 0.0
        
        if position_notional <= 50000
            maintenance_margin_rate := 0.004  // 0.4%
            maintenance_amount := 0
        else if position_notional <= 250000
            maintenance_margin_rate := 0.005  // 0.5%
            maintenance_amount := 0
        else if position_notional <= 1000000
            maintenance_margin_rate := 0.01   // 1.0%
            maintenance_amount := 1300
        else if position_notional <= 5000000
            maintenance_margin_rate := 0.025  // 2.5%
            maintenance_amount := 16300
        else if position_notional <= 10000000
            maintenance_margin_rate := 0.05   // 5.0%
            maintenance_amount := 63800
        else if position_notional <= 20000000
            maintenance_margin_rate := 0.10   // 10.0%
            maintenance_amount := 135365
        else
            maintenance_margin_rate := 0.125  // 12.5%
            maintenance_amount := 135365
        
        // ìœ ì§€ì¦ê±°ê¸ˆ ê³„ì‚°
        maintenance_margin = (position_notional * maintenance_margin_rate) - maintenance_amount
        
        // ë°”ì´ë‚¸ìŠ¤ ì²­ì‚°ê°€ ê³µì‹ ì ìš©
        if maintenance_margin_rate > 0 and total_position_value > 0
            avg_price - (current_equity - maintenance_margin) / (total_position_value * maintenance_margin_rate)
        else
            na

// Entry Logic
positionSize := math.round(capitalPerOnce / close * 1000)/ 1000
stoploss := additionalEntryPrice - (2.5* atr)   

// entryCountê°€ 1, 2ì¼ ë•ŒëŠ” ì²­ì‚°ê°€ë¥¼ ê°•ì œë¡œ naë¡œ ì„¤ì •
if entryCount <= 2
    liquidation_price := na

if strategy.opentrades < inputTrade and positionSize > 0 and in_backtest_period
    // First Entry
    if (val > 0 and entryCount == 0  and  close > open ) 
        initialEntryPrice := close
        initialPositionSize := positionSize  // ì´ˆê¸° ì§„ì… ì‹œ positionSize ì €ì¥
        
        // ğŸ†• ì‚¬ì´í´ ì‹œì‘ ì‹œ ìë³¸ ê³ ì •
        cycle_start_capital := strategy.equity
        
        // ë°”ì´ë‚¸ìŠ¤ í‰ê· ê°€ ê³„ì‚°
        total_cost := close * positionSize
        total_quantity := positionSize
        avgPrice := total_cost / total_quantity
        
        // ë°”ì´ë‚¸ìŠ¤ ì²­ì‚°ê°€ ê³„ì‚° (ì²« ì§„ì… ì‹œ) - strategy_martin.pyì™€ ë™ì¼
        total_position_value := total_quantity * close
        // ë™ì  ë ˆë²„ë¦¬ì§€ ê³„ì‚°
        float actual_leverage = calculate_actual_leverage(entryCount, leverage, dividedLongCount, total_position_value, cycle_start_capital)
        // ë°”ì´ë‚¸ìŠ¤ ì²­ì‚°ê°€ ê³„ì‚° (ë™ì  ë ˆë²„ë¦¬ì§€ ì‚¬ìš©) - ì²« ì§„ì… ì‹œì—ëŠ” ì²­ì‚°ê°€ ì—†ìŒ
        liquidation_price := na
        
        strategy.order("longPosition", strategy.long, qty=positionSize)
        
        // strategy.order("longPosition", strategy.long, qty=positionSize)
        
        entryCount := 1
       
        log.info("Entry 1 at {0}, avgPrice: {1}, initialPositionSize: {2}, ì²­ì‚°ê°€: ì—†ìŒ (ì²« ì§„ì…), ì‹¤ì œë ˆë²„ë¦¬ì§€: {3}ë°°", close, avgPrice, initialPositionSize, actual_leverage)
        
    // Second and Subsequent Entries (up to 10)
    if (entryCount >= 1 and entryCount < inputTrade)
        if (avgPrice - close)  > stoploss * entryCount 
            secondEntryPrice := close 
            
            // ë°”ì´ë‚¸ìŠ¤ í‰ê· ê°€ ê³„ì‚° (ì¦ë¶„ ë°©ì‹)
            new_cost = close * positionSize
            total_cost := total_cost + new_cost
            total_quantity := total_quantity + positionSize
            avgPrice := total_cost / total_quantity
            
            // ë°”ì´ë‚¸ìŠ¤ ì²­ì‚°ê°€ ì¬ê³„ì‚° (strategy_martin.pyì™€ ë™ì¼)
            total_position_value := total_quantity * close
            // ë™ì  ë ˆë²„ë¦¬ì§€ ì¬ê³„ì‚°
            float actual_leverage = calculate_actual_leverage(entryCount, leverage, dividedLongCount, total_position_value, cycle_start_capital)
            
            strategy.order("longPosition", strategy.long, qty=positionSize)
            
            // strategy.order("longPosition", strategy.long, qty=positionSize)
            
            entryCount += 1
            
            // entryCount ì—…ë°ì´íŠ¸ í›„ ì²­ì‚°ê°€ ì¬ê³„ì‚°
            liquidation_price := calculate_martingale_liquidation_price(avgPrice, entryCount, leverage, dividedLongCount, total_position_value, cycle_start_capital)
            
            log.info("Entry {0} at {1}, avgPrice: {2}, ì²­ì‚°ê°€: {3}, ì‹¤ì œë ˆë²„ë¦¬ì§€: {4}ë°°, entryCount: {5}", entryCount, close, avgPrice, liquidation_price, actual_leverage, entryCount)

// ğŸ†• ìˆ˜ì •ëœ ë°”ì´ë‚¸ìŠ¤ ì²­ì‚°ê°€ ëª¨ë‹ˆí„°ë§
if strategy.position_size > 0 and entryCount >= 3 and not na(liquidation_price) and in_backtest_period
    // ë™ì  ë ˆë²„ë¦¬ì§€ ê³„ì‚°
    float actual_leverage = calculate_actual_leverage(entryCount, leverage, dividedLongCount, total_position_value, cycle_start_capital)
    
    // ì²­ì‚°ê°€ ìœ„í—˜ë„ ê³„ì‚°
    float distance_to_liquidation = close - liquidation_price
    float distance_percentage = (distance_to_liquidation / liquidation_price) * 100
    
    // ì´ë¡ ìƒ ì²­ì‚° í•˜ë½ë¥  ê³„ì‚°
    float theoretical_liquidation_drop = actual_leverage > 0 ? 100 / actual_leverage : 0
    
    // í˜„ì¬ í•˜ë½ë¥  ê³„ì‚°
    float current_drop_percentage = ((avgPrice - close) / avgPrice) * 100
    
    // ì²­ì‚° ìœ„í—˜ ê²½ê³  (ì²­ì‚°ê°€ ëŒ€ë¹„ 5% ì´ë‚´)
    if close <= liquidation_price * 1.05
        log.info("ğŸš¨ ì²­ì‚° ìœ„í—˜: í˜„ì¬ê°€={0}, ì²­ì‚°ê°€={1}, ê±°ë¦¬={2}%", close, liquidation_price, distance_percentage)
        log.info("ğŸš¨ ë ˆë²„ë¦¬ì§€ ì •ë³´: ì§„ì…íšŸìˆ˜={0}, ì‹¤ì œë ˆë²„ë¦¬ì§€={1}ë°°, ì´ë¡ ìƒì²­ì‚°í•˜ë½ë¥ ={2}%", entryCount, actual_leverage, str.tostring(theoretical_liquidation_drop))
        log.info("ğŸš¨ í˜„ì¬ í•˜ë½ë¥ : {0}% (ì²­ì‚°ê¹Œì§€ {1}% ì—¬ìœ )", current_drop_percentage, str.tostring(theoretical_liquidation_drop - current_drop_percentage))
    
    // ì‹¤ì œ ì²­ì‚° ì²´í¬ (ë” ì•ˆì „í•œ ì¡°ê±´ìœ¼ë¡œ ìˆ˜ì •)
    if close <= liquidation_price * 1.01  // 1.02ì—ì„œ 1.01ë¡œ ë³€ê²½í•˜ì—¬ ë” ì—„ê²©í•˜ê²Œ
        strategy.close_all("ë°”ì´ë‚¸ìŠ¤ ì²­ì‚°")
        // strategy.close_all("ë°”ì´ë‚¸ìŠ¤ ì²­ì‚°")
        log.info("ğŸš¨ ë°”ì´ë‚¸ìŠ¤ ì²­ì‚° ë°œìƒ: í˜„ì¬ê°€={0}, ì²­ì‚°ê°€={1}", close, liquidation_price)
        log.info("ğŸš¨ ë§ˆì§„ì½œ ìƒì„¸: í‰ë‹¨ê°€={0}, ì§„ì…íšŸìˆ˜={1}, ì‹¤ì œë ˆë²„ë¦¬ì§€={2}ë°°", avgPrice, entryCount, actual_leverage)
        log.info("ğŸš¨ ì†ì‹¤ë¥ : {0}% (ì´ë¡ ìƒ ì²­ì‚°ë¥ : {1}%)", current_drop_percentage, str.tostring(theoretical_liquidation_drop))

// Partial Exit Logic (ë°”ì´ë‚¸ìŠ¤ ë°©ì‹)
if (entryCount >= 2 and (close > avgPrice * 1.0035) and  not na(avgPrice)) and in_backtest_period
    qty = strategy.position_size - initialPositionSize  // í˜„ì¬ í¬ì§€ì…˜ì—ì„œ ì´ˆê¸° positionSizeë¥¼ ì œì™¸í•œ ìˆ˜ëŸ‰ ì²­ì‚°
    
    // ë°”ì´ë‚¸ìŠ¤ ë°©ì‹: ë§¤ë„ ì‹œ í‰ê· ê°€ ìœ ì§€, ìˆ˜ëŸ‰ë§Œ ê°ì†Œ
    removed_cost = avgPrice * qty
    total_cost := total_cost - removed_cost
    total_quantity := total_quantity - qty
    
    strategy.close("longPosition", comment="ì´ˆê¸° íˆ¬ì… ë¬¼ëŸ‰ ë¹¼ê³  ì²­ì‚°", qty = qty)
    
    // strategy.close("longPosition", comment="ì´ˆê¸° íˆ¬ì… ë¬¼ëŸ‰ ë¹¼ê³  ì²­ì‚°", qty = qty)
    
    // ğŸ†• ìˆ˜ì •: Partial Exit í›„ì—ëŠ” entryCountë¥¼ 1ë¡œ ì„¤ì •í•˜ê³  ì²­ì‚°ê°€ë¥¼ naë¡œ ì„¤ì •
    entryCount := 1
    liquidation_price := na  // Partial Exit í›„ì—ëŠ” ì²­ì‚°ê°€ ì—†ìŒ
    cycle_start_capital := na  // ğŸ†• ì‚¬ì´í´ ì‹œì‘ ìë³¸ ì´ˆê¸°í™” (Partial Exit í›„)
    
    log.info("ì´ˆê¸° íˆ¬ì… ë¬¼ëŸ‰ ë¹¼ê³  ì²­ì‚° at {0}, avgPrice: {1}, qty: {2}, strategy.position_size: {3}, ì²­ì‚°ê°€: ì—†ìŒ (Partial Exit í›„), entryCount: {4}", close, avgPrice, qty, strategy.position_size, entryCount)

// ì „ì²´ ì²­ì‚°
if (entryCount == 1 and (close >= (avgPrice * profit) )) and in_backtest_period
    qty=positionSize
    strategy.close_all("ì¢…ë£Œ")
    // strategy.close_all("ì¢…ë£Œ")
    log.info("exit all at {0}, avgPrice: {1}", close, avgPrice)
    
    // ë°”ì´ë‚¸ìŠ¤ ë°©ì‹: ëª¨ë“  í¬ì§€ì…˜ ì²­ì‚° ì‹œ ë³€ìˆ˜ ì´ˆê¸°í™”
    avgPrice := 0
    total_cost := 0
    total_quantity := 0
    initialEntryPrice := 0
    secondEntryPrice := 0
    liquidation_price := na
    total_position_value := 0.0
    cycle_start_capital := na  // ğŸ†• ì‚¬ì´í´ ì‹œì‘ ìë³¸ ì´ˆê¸°í™”
    
    entryCount := 0

// ==================== í”Œë¡¯ ====================
// plot(avgPrice, title="í‰ë‹¨ê°€", color=color.blue, linewidth=2)
// plot(liquidation_price, title="ë°”ì´ë‚¸ìŠ¤ ì²­ì‚°ê°€", color=color.orange, linewidth=2, style=plot.style_line)

// // ì²­ì‚° ìœ„í—˜ êµ¬ê°„ í‘œì‹œ
// bgcolor(close <= liquidation_price * 1.05 and strategy.position_size > 0 ? color.new(color.red, 90) : na, title="ì²­ì‚° ìœ„í—˜ êµ¬ê°„")

// í…Œì´ë¸” ìƒì„± (í•œ ë²ˆë§Œ)
var table info_table = table.new(position.top_right, 2, 7, bgcolor=color.new(color.black, 80), border_width=1)

// í…Œì´ë¸” ì—…ë°ì´íŠ¸
if barstate.islast
    // í…Œì´ë¸” í—¤ë”
    table.cell(info_table, 0, 0, "í•­ëª©", text_color=color.white, bgcolor=color.new(color.blue, 50))
    table.cell(info_table, 1, 0, "ê°’", text_color=color.white, bgcolor=color.new(color.blue, 50))
    
    // í˜„ì¬ê°€
    table.cell(info_table, 0, 1, "í˜„ì¬ê°€", text_color=color.white)
    table.cell(info_table, 1, 1, str.tostring(close, "#.##"), text_color=color.white)
    
    // í‰ë‹¨ê°€
    table.cell(info_table, 0, 2, "í‰ë‹¨ê°€", text_color=color.white)
    table.cell(info_table, 1, 2, na(avgPrice) ? "0" : str.tostring(avgPrice, "#.##"), 
               text_color=na(avgPrice) ? color.gray : color.blue)
    
    // ì²­ì‚°ê°€ - entryCountê°€ 1ì¼ ë•ŒëŠ” í‘œì‹œí•˜ì§€ ì•ŠìŒ
    table.cell(info_table, 0, 3, "ì²­ì‚°ê°€", text_color=color.white)
    table.cell(info_table, 1, 3, (entryCount <= 1 or na(liquidation_price)) ? "0" : str.tostring(liquidation_price, "#.##"), 
               text_color=(entryCount <= 1 or na(liquidation_price)) ? color.gray : color.orange)
    
    // ì§„ì… íšŸìˆ˜
    table.cell(info_table, 0, 4, "ì§„ì…íšŸìˆ˜", text_color=color.white)
    table.cell(info_table, 1, 4, str.tostring(entryCount), text_color=color.white)
    
    // í¬ì§€ì…˜ í¬ê¸°
    table.cell(info_table, 0, 5, "í¬ì§€ì…˜í¬ê¸°", text_color=color.white)
    table.cell(info_table, 1, 5, str.tostring(strategy.position_size, "#.####"), 
               text_color=strategy.position_size > 0 ? color.green : color.gray)
    
    // ğŸ†• ì‹¤ì œë ˆë²„ë¦¬ì§€ í‘œì‹œ
    table.cell(info_table, 0, 6, "ì‹¤ì œë ˆë²„ë¦¬ì§€", text_color=color.white)
    table.cell(info_table, 1, 6, entryCount > 0 ? str.tostring(calculate_actual_leverage(entryCount, leverage, dividedLongCount, total_position_value, cycle_start_capital), "#.##") + "ë°°" : "0ë°°", 
               text_color=entryCount > 0 ? color.yellow : color.gray)
